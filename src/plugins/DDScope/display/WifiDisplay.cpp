// =====================================================
// WifiDisplay.cpp
//
// See rights and use declaration in License.h
//
// **** by Richard Benear 3/21/2025 ****
// Added a faster drawRect().
// Also, added ability to capture the pixels going to each screen of the TFT
// into a RAM buffer and then store each screen file on the SD Flash. The SD
// flash can then be read by a python script "TftCapture/display_sd_image.py"
// which converts the color format to viewable .png files. These screen images
// are much more readable and representative of what is actually seen on the
// TFT. This was done primarily for documentation because the ones that were
// generated by taking photos of the handheld TFT display had too much backlight
// glow.

// Added 4/15/2025 TFT Screen Mirror a.k.a WiFi Display
// Functions to support the capture of the SPI data to the TFT into buffer,
// compress and then forward to external ESP32-S3 to be sent wirelessly to web page.
// Essentially, it is a WiFi TFT Screen Mirror.
//

#include "WifiDisplay.h"
#include "../display/Display.h"
#include "../display/UsbBridge.h"
#include "miniz.h"
#include <Arduino.h>
#include <SD.h>
#include "../lx200/LX200Handler.h"

#define ACK 0x06
#define NACK 0x15

// DMAMEM is 512KB or not big enough, using 8 MB PSRAM that is added to base Teensy4.1
// So must use EXTMEM
EXTMEM uint8_t compressedBuffer[COMPRESSED_BUFFER_SIZE];
EXTMEM uint8_t uncompressedBuffer[UNCOMPRESSED_BUFFER_SIZE];

bool espIsReady = false;

// States
enum TeensyCommState {
  WAIT_FOR_IP,
  WAIT_FOR_CLIENT_CONNECTED,
  CHECK_FOR_DISCONNECT,
  CHECK_FOR_LX200_COMMAND,
  SEND_FRAME,
  WAIT_FOR_FRAME_ACK
};

TeensyCommState teensyState = WAIT_FOR_IP;

void WifiDisplay::take_esp_lock() {
  noInterrupts(); // Begin critical section
  while (espIsLocked) {
    interrupts(); // Re-enable while waiting (to allow task switching)
    delayMicroseconds(10);
    noInterrupts(); // Disable again to retry checking
  }
  espIsLocked = true;
  interrupts(); // End critical section
}

void WifiDisplay::give_esp_lock() {
  noInterrupts();
  espIsLocked = false;
  interrupts();
}

// =================================================================
// *** Functions to enable capture a screen and redirect it to WiFi *****
void WifiDisplay::enableScreenCapture(bool enable) {
  if (isScreenCaptureEnabled) {
  }
  isScreenCaptureEnabled = enable;
}

// Frame send ACK handler
bool waitForEspACK(unsigned long timeoutMillis) {
  unsigned long ackTime = millis();

  while (millis() - ackTime < timeoutMillis) {
    if (SERIAL_ESP32S3.available()) {
      char incoming = SERIAL_ESP32S3.read();
      if (incoming == ACK) {
        return true;
      }
    }
    yield();
  }
  return false; // Timed out
}

// ==================== Deflate Compression ====================
size_t WifiDisplay::compressWithDeflate() {
  memset(compressedBuffer, 0, COMPRESSED_BUFFER_SIZE);

  mz_stream stream = {0};
  stream.next_in = uncompressedBuffer;
  stream.avail_in = UNCOMPRESSED_BUFFER_SIZE;
  stream.next_out = compressedBuffer;
  stream.avail_out = COMPRESSED_BUFFER_SIZE;

  // Use mz_deflateInit2 with negative windowBits to get raw deflate
  int status = mz_deflateInit2(&stream, MZ_DEFAULT_COMPRESSION, MZ_DEFLATED,
                               -MZ_DEFAULT_WINDOW_BITS, 9, 0);
  if (status != MZ_OK) {
    SERIAL_DEBUG.println("Deflate init failed");
    return 0;
  }

  status = mz_deflate(&stream, MZ_FINISH);
  if (status != MZ_STREAM_END) {
    SERIAL_DEBUG.println("Deflate compression failed");
    mz_deflateEnd(&stream);
    return 0;
  }

  size_t compressedSize = stream.total_out;
  mz_deflateEnd(&stream);

  // SERIAL_DEBUG.printf("Deflated %u -> %u bytes\n", UNCOMPRESSED_BUFFER_SIZE,
  //               compressedSize);

  return compressedSize;
}

// ==================== RLE Compression Function ====================
// This function implements a Run-Length Encoding (RLE) compression algorithm
// tailored for 16-bit RGB565 pixel data. It compresses a framebuffer of
// uncompressed RGB565 pixels (stored in uncompressedBuffer) and writes the
// compressed data to compressedBuffer. It reads a 16-bit pixel from the
// uncompressedBuffer, treating it as big-endian (high byte first), unless
// USE_LITTLE_ENDIAN is defined. It then loop to find how many times the current
// pixel repeats consecutively in the buffer (up to a max of 255, since the run
// length is stored in 1 byte). Depending on endian mode: Big-endian stores the
// pixel as [highByte][lowByte]. Then stores the runLength as 1 byte. Each
// encoded segment uses 3 bytes to represent: A 16-bit RGB565 color and a repeat
// count (1â€“255)
// =================== RLE Compression ============================
size_t WifiDisplay::compressWithRLE() {
  size_t writeIndex = 0;
  size_t readIndex = 0;

  while (readIndex < UNCOMPRESSED_BUFFER_SIZE) {
    uint16_t currentPixel = (uncompressedBuffer[readIndex] << 8) |
                            uncompressedBuffer[readIndex + 1];

    size_t runLength = 1;
    readIndex += 2;

    while (readIndex < UNCOMPRESSED_BUFFER_SIZE && runLength < 255) {
      uint16_t nextPixel = (uncompressedBuffer[readIndex] << 8) |
                           uncompressedBuffer[readIndex + 1];

      if (nextPixel != currentPixel)
        break; // end of normal color run
      runLength++;
      readIndex += 2;
    }

    if (writeIndex + 3 > COMPRESSED_BUFFER_SIZE) {
      SERIAL_DEBUG.println("ERROR: Compressed buffer overflow.");
      return 0;
    }
    // Write RLE: big endian color + run length
    compressedBuffer[writeIndex++] = (currentPixel >> 8) & 0xFF;
    compressedBuffer[writeIndex++] = currentPixel & 0xFF;
    compressedBuffer[writeIndex++] = runLength;
  }
  // SERIAL_DEBUG.print("Compressed Size: ");
  // SERIAL_DEBUG.println(writeIndex);
  return writeIndex;
}

// =============== Teensy ESP Communication State Machine =================
// Byte Legend:
//   'I' = ESP32S3 sends IP address (e.g., I192.168.1.55\n)
//   'C' = ESP32S3 says client is connected
//   'D' = ESP32S3 says client disconnected
//   'T' = ESP32S3 touchscreen event (ignored)
//   'Z' = Teensy sends start-of-frame to ESP32S3
//
// State Transition Table:
// +---------------------------+----------------+-------------------------------+--------------------+
// | State                     | In Byte  | Action                     | Next State                  |
// +---------------------------+----------------+-------------------------------+--------------------+
// | WAIT_FOR_IP               | 'I'      | Parse IP, send 'K'         |WAIT_FOR_CLIENT_CONNECTED    |
// +---------------------------+----------------+-------------------------------+--------------------+
// | WAIT_FOR_CLIENT_CONNECTED | 'C'      | Send 'K',  enable sendframe|WAIT_FOR_IP  (if disconnect) |
// +---------------------------+----------------+-------------------------------+--------------------+
//
// Notes:
// - Touchscreen bytes 'T' are ignored in State Machine but, if detected by
//   sendFrameToEsp(), will skip that frame.
// - State reset via 'D' (disconnect) sets state back to WAIT_FOR_IP

// ======== Teensy to ESP communication State Machine ========
void WifiDisplay::espPoll() {
  // take_esp_lock();

  if (SERIAL_ESP32S3.available()) {
    char incoming = SERIAL_ESP32S3.peek();

    if (incoming == 'D') {
      SERIAL_ESP32S3.read(); // consume it
      SERIAL_DEBUG.println("Received disconnected signal 'D'");
      espIsReady = false;
      teensyState = WAIT_FOR_IP;
      // give_esp_lock();
      return;
    }
  }

  if (SERIAL_ESP32S3.available()) {
    char peekChar = SERIAL_ESP32S3.peek();
    if (peekChar == 'T') {
      // give_esp_lock();
      return;
    }

    // Process incoming
    char incoming = SERIAL_ESP32S3.read();

    switch (teensyState) {
    case WAIT_FOR_IP:
    wifiStaIpStr = "";
      if (incoming == 'I') {
        SERIAL_DEBUG.println("Sending IP ACK");
        SERIAL_ESP32S3.write('K'); // IP ACK
        SERIAL_ESP32S3.flush();
        while (SERIAL_ESP32S3.available()) {
          char c = SERIAL_ESP32S3.read();
          if (c == '\n')
            break;
          wifiStaIpStr += c;
        }
        SERIAL_DEBUG.print("IP Address: I");
        SERIAL_DEBUG.println(wifiStaIpStr);

        // Print the IP address on the Home Screen
        if (display.currentScreen == HOME_SCREEN) {
          tft.fillRect(170, 300, 140, 20, butBackground); // Clear old IP area
          tft.setCursor(170, 312);
          tft.print("I");
          tft.print(wifiStaIpStr);
        }
        teensyState = WAIT_FOR_CLIENT_CONNECTED;
      }
      break;

    case WAIT_FOR_CLIENT_CONNECTED:
      if (incoming == 'C') {
        SERIAL_DEBUG.println("Web Client Connected");
        SERIAL_ESP32S3.write('K'); // Client Connect ACK
        SERIAL_ESP32S3.flush();
        espIsReady = true;
        // teensyState = SEND_FRAME;
      }
      break;

      // This STATE not used because state machine only changes when 
      // serial.available().
      // case SEND_FRAME:
      //   SERIAL_DEBUG.println("ESP Ready");
      //   espIsReady = true;
      //   break;

    default:
      SERIAL_DEBUG.println("Bad State");
      break;
    }
  }
  // give_esp_lock();
}

// Z (0x5A)= Reset ESP32-S3 state
// T (0x54)= Touch
// ================ Send Buffer =================================
void WifiDisplay::sendFrameToEsp(uint8_t frameType) {
  if (!espIsReady) {
    SERIAL_DEBUG.println("ESP not ready");
    return;
  }

  // take_esp_lock();

  // Check if any status byte is available from ESP
  if (SERIAL_ESP32S3.available()) {
    char peekChar = SERIAL_ESP32S3.peek();
    //SERIAL_DEBUG.print(peekChar);
    if (peekChar == 'T' || 'D') {
      // give_esp_lock();
      return;
    }
  }

  // clear any junk
  // while (SERIAL_ESP32S3.available()) {
  //   SERIAL_ESP32S3.read();
  // }
  // delay(3);
  // === Prepare Size of Payload ===
  size_t bufSize = 0;
  const uint8_t *bufferToSend = nullptr;

  if (frameType == FRAME_TYPE_RLE) {
    bufSize = compressWithRLE();
    if (bufSize == 0) {
      give_esp_lock();
      return;
    }
    bufferToSend = compressedBuffer;
    // SERIAL_DEBUG.println("Sending RLE frame to ESP32-S3");
  } else if (frameType == FRAME_TYPE_DEF) {
    bufSize = compressWithDeflate();
    if (bufSize == 0) {
      give_esp_lock();
      return;
    }
    bufferToSend = compressedBuffer;
    // SERIAL_DEBUG.println("Sending Deflate frame to ESP32-S3");
  } else if (frameType == FRAME_TYPE_RAW) {
    bufSize = UNCOMPRESSED_BUFFER_SIZE;
    bufferToSend = uncompressedBuffer;
  } else {
    SERIAL_DEBUG.printf("Unknown FRAME TYPE");
    give_esp_lock();
    return;
  }

  // Is ESP ready for Frame
  // SERIAL_DEBUG.println("Sending 'Z'");
  SERIAL_ESP32S3.write('Z');
  SERIAL_ESP32S3.flush();

  // get ESP ACK
  bool ackReceived = false;
  unsigned long ackTime = millis();
  while (millis() - ackTime < 20) {
    if (SERIAL_ESP32S3.available()) {
      char incoming = SERIAL_ESP32S3.read();
      if (incoming == ACK) {
        ackReceived = true;
        // SERIAL_DEBUG.println("Frame ACK from ESP");
        break;
      }
    }
    //yield();
  }

  if (!ackReceived) {
    SERIAL_DEBUG.println("No ESP32S3 ACK");
    // espIsReady = false;
    // give_esp_lock();
    return;
  }

  // SERIAL_DEBUG.printf("Sending bufSize (%u bytes) as [0x%02X 0x%02X 0x%02X
  // 0x%02X]\n",
  //             bufSize,
  //             (uint8_t)(bufSize & 0xFF),
  //             (uint8_t)((bufSize >> 8) & 0xFF),
  //             (uint8_t)((bufSize >> 16) & 0xFF),
  //             (uint8_t)((bufSize >> 24) & 0xFF)
  //);
  //  === Send Type and Size Header ===
  SERIAL_ESP32S3.write(frameType);
  SERIAL_ESP32S3.write((uint8_t)(bufSize & 0xFF));
  SERIAL_ESP32S3.write((uint8_t)((bufSize >> 8) & 0xFF));
  SERIAL_ESP32S3.write((uint8_t)((bufSize >> 16) & 0xFF));
  SERIAL_ESP32S3.write((uint8_t)((bufSize >> 24) & 0xFF));
  SERIAL_ESP32S3.flush();

  // --- Send Payload in 64-byte Chunks with Flow Control ---
  int totalSent = 0;
  const size_t packetSize = 64;

  for (size_t i = 0; i < bufSize; i += packetSize) {
    int chunkSize = min(packetSize, bufSize - i);

    // Wait until there's space to send the next chunk
    while (SERIAL_ESP32S3.availableForWrite() < chunkSize) {
      yield(); // Let background USB and other tasks run (required for correct
               // operation)
    }

    int sent = SERIAL_ESP32S3.write(bufferToSend + i, chunkSize);
    totalSent += sent;
    delayMicroseconds(200); // Tune this if needed
  }
  SERIAL_ESP32S3.flush();
  // unsigned long elapsed = millis() - startTime;
  // SERIAL_DEBUG.printf("Sent %d bytes in %d ms\n", totalSent, elapsed);
  //  NOTE: the longest elapsed time to compress and send is approx 143 msec.
  // give_esp_lock();
}

// ==================== Save Buffer to SD Card ====================
void WifiDisplay::saveBufferToSD(const char *screenName) {
  // Build the file name based on the screen name
  char fileName[64];
  snprintf(fileName, sizeof(fileName), "/tft_%s_log.bin", screenName);

  // Remove the file if it already exist
  if (SD.exists(fileName)) {
    SD.remove(fileName); // Delete the file to ensure it's completely erased
  }

  // Open the file for writing (overwrite existing file)
  File logFile = SD.open(fileName, (uint8_t)(O_WRITE | O_CREAT));
  if (logFile) {
    // logFile.write(uncompressedBuffer, UNCOMPRESSED_BUFFER_SIZE);
    SERIAL_DEBUG.print("File size: ");
    SERIAL_DEBUG.println(logFile.size());
    logFile.close();
    SERIAL_DEBUG.print("Buffer saved to SD card as: ");
    SERIAL_DEBUG.println(fileName);
  } else {
    SERIAL_DEBUG.println("Failed to open file for writing.");
  }
  // Clear the buffer (Overwrite with zeros)
  memset(uncompressedBuffer, 0, UNCOMPRESSED_BUFFER_SIZE);
}
